/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */

import { Keyring } from '@polkadot/keyring'
import { decodePair } from '@polkadot/keyring/pair/decode'
import { hexToU8a, isHex } from '@polkadot/util'
import {
  ed25519PairFromSeed,
  randomAsHex,
  secp256k1PairFromSeed,
  sr25519PairFromSeed,
  naclBoxPairFromSecret,
  keyFromPath,
  keyExtractPath,
  mnemonicToMiniSecret,
} from '@polkadot/util-crypto'
import { Keypair } from '@polkadot/util-crypto/types'
import { HexString } from '@polkadot/util/types'

import {
  VerificationKeyType,
  KiltKeyringPair,
  EncryptionKeyType,
  verificationKeyTypes,
} from '@kiltprotocol/types'

import { UnsupportedKeyError } from './SDKErrors.js'

export { mnemonicGenerate as generateMnemonic } from '@polkadot/util-crypto'

/**
 * Randomly generates a new 32 byte secret.
 *
 * @returns Secret encoded as a 0x-prefixed hex string.
 */
export function generateSecret(): HexString {
  return randomAsHex(32)
}

const PairFromSeed: Record<string, (seed: Uint8Array) => Keypair> = {
  ecdsa: (seed) => secp256k1PairFromSeed(seed),
  ed25519: (seed) => ed25519PairFromSeed(seed),
  sr25519: (seed) => sr25519PairFromSeed(seed),
  x25519: (seed) => naclBoxPairFromSecret(seed),
}

/**
 * Creates an encryption or verification key pair from a mnemonic or hex-encoded secret.
 *
 * @param type {Verification|Encryption} Key type.
 * @param mnemonicOrSeed A BIP39 mnemonic or 32 byte hex string.
 * @param derivationPath Key derivation path beginning with `//` or `/', e.g. `//hard/soft`.
 * @returns An object containing public and secret keys.
 */
export function createKeypair(
  type: VerificationKeyType | EncryptionKeyType,
  mnemonicOrSeed: string | HexString,
  derivationPath: string
): Keypair {
  if (!Object.prototype.hasOwnProperty.call(PairFromSeed, type)) {
    throw new UnsupportedKeyError(type)
  }
  const seed = isHex(mnemonicOrSeed)
    ? hexToU8a(mnemonicOrSeed)
    : mnemonicToMiniSecret(mnemonicOrSeed)
  let pair = PairFromSeed[type](seed)
  if (derivationPath) {
    const { path } = keyExtractPath(derivationPath)
    pair = keyFromPath(pair, path, type === 'x25519' ? 'ed25519' : type)
    if (type === 'x25519') {
      pair = PairFromSeed[type](pair.secretKey)
    }
  }
  return pair
}

const keyring = new Keyring({ ss58Format: 38 })

/**
 * Creates a KeyringPair instance which can be used for signing.
 *
 * @param pair A verification key pair as created by [[createKeypair]].
 * @param type Key type of the pair.
 * @returns KeyringPair instance defaulting to Kilt address encoding.
 */
export function createSigningKeyRingPair(
  pair: Keypair,
  type: VerificationKeyType
): KiltKeyringPair {
  if (!verificationKeyTypes.includes(type)) throw new UnsupportedKeyError(type)
  return keyring.createFromPair(pair, undefined, type) as KiltKeyringPair
}

/**
 * Decodes the pkcs8 encoding of a KeyPair / KeyringPair.
 * A combination of encodePkcs8 & decodePkcs8 can also be used to extract public & secret keys from a KeyringPair.
 *
 * @example
 * // extracts secret key from KeyringPair
 * const keyRingPair = Keyring.createFromUri(...mnemonic...)
 * const encoded = pair.encodePkcs8('xxx')
 * const { secretKey } = decodePkcs8('xxx')
 * @param encodeKeypair Pkcs8 encoding of the key pair e.g. As generated by `KeyringPair.encodePkcs8()`.
 * @param passphrase Passphrase used to encrypt the key pair.
 * @returns A Keypair object containing public & secret keys.
 */
export function decodePkcs8(
  encodeKeypair: Uint8Array,
  passphrase: string
): Keypair {
  return decodePair(passphrase, encodeKeypair)
}
